# A0139958H
###### /java/seedu/task/logic/commands/AddCommand.java
``` java
/**
 * Adds a task to the taskBook.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the taskBook. "
            + "Example: " + COMMAND_WORD
            + " shopping with friends tomorrow evening 7pm to 10pm #high #shopping #evening /n"
            + " # - For tags, priority level (#high, #medium, #low) /n"
            + " @ - Venue";

    public static final String MESSAGE_SUCCESS = "New task added: %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the taskBook";

    private final Task toAdd;

    /**
     * Parameter: Task Object
     *
     * 
     */
    public AddCommand(Task task) {
    	if (task == null)
    		throw new NullPointerException();
    	this.toAdd = task;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            int taskIndex = model.addTask(toAdd);
            Undo.getInstance().setUndo(taskIndex, toAdd, Undo.UndoCommand.ADD);
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        } catch (UniqueTaskList.DateClashTaskException e) {
            return new CommandResult(e.getMessage());
        } 
        return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
    }

}
```
###### /java/seedu/task/logic/commands/DeleteCommand.java
``` java

/**
 * Deletes a task identified using it's last displayed index from the task book.
 */
public class DeleteCommand extends Command {

	public static final String COMMAND_WORD = "delete";

	public static final String MESSAGE_USAGE = COMMAND_WORD
	        + ": Deletes the tasks identified by their index number used in the last task listing.\n"
	        + "Parameters: INDEXES (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 1 2";

	public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %s";

	public final int[] targetIndexes;

	public DeleteCommand(int[] targetIndexes) {
		this.targetIndexes = targetIndexes;
	}

	@Override
	public CommandResult execute() {

		UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedTaskList();
		List<Integer> invalidIndexes = new ArrayList<>();

		for (int i = 0; i < targetIndexes.length; i++) {
			if (lastShownList.size() < targetIndexes[i])
				invalidIndexes.add(targetIndexes[i]);
		}

		if (!invalidIndexes.isEmpty()) {
			indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(String.format(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX,
			        Arrays.toString(invalidIndexes.toArray())));
		}

		try {
			for (int i = 0; i < targetIndexes.length; i++) {
				LogsCenter.getLogger(DeleteCommand.class).info("Delete Task: " + (targetIndexes[i] - i - 1));
				ReadOnlyTask taskToDelete = model.getTaskByIndex(targetIndexes[i] - i - 1);
				model.deleteTask(taskToDelete);
				Undo.getInstance().setUndo(targetIndexes[i] - i - 1, (Task) taskToDelete, Undo.UndoCommand.DELETE);
			}
		} catch (TaskNotFoundException tnfe) {
			assert false : "The target task cannot be missing";
		}

		return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, Arrays.toString(targetIndexes)));
	}

}
```
###### /java/seedu/task/logic/commands/SetCommand.java
``` java

public class SetCommand extends Command{
    public static final String COMMAND_WORD = "set";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": set the task status to marked as done or ignore.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 done";

    public static final String MESSAGE_SUCCESS = "Updated the status of task %1$s";
    public static final String MESSAGE_STATUS_CONSTRAINT = "Task status can only be updated to Done or Ignore";
    public static final String MESSAGE_STATUS_DONE = "Task status has been already set to Done";
    
    private final int taskIndex;
    private final String setArg;

    
    /**
     * Parameter: Task Index, Arguments to be updated
     *
     * 
     */
    public SetCommand(int taskIndex, String setArg) {
    	this.taskIndex = taskIndex;
    	this.setArg = setArg;
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedTaskList();

        if (lastShownList.size() < taskIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    	
        assert model != null;
        try {
        	TaskParser updateTaskParser = new UpdateTaskParser(model.getTaskByIndex(taskIndex - 1), setArg);
        	LogsCenter.getLogger(ModelManager.class).info("Task Index: " + (taskIndex - 1) + " task: " + model.getTaskByIndex(taskIndex - 1));

        	model.updateTask(model.getTaskByIndex(taskIndex - 1), ((UpdateTaskParser) updateTaskParser).setTaskStatus());
		} catch (IllegalValueException e) {
	        indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(e.getMessage());
		}

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskIndex));
    }
}
```
###### /java/seedu/task/logic/commands/UndoCommand.java
``` java

import seedu.task.commons.core.LogsCenter;
import seedu.task.model.ModelManager;
import seedu.task.model.Undo;
import seedu.task.model.task.UniqueTaskList;
import seedu.task.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.task.model.task.UniqueTaskList.TaskNotFoundException;

public class UndoCommand extends Command {
	public static final String COMMAND_WORD = "undo";
	public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo the last command ";
	public static final String MESSAGE_SUCCESS_UNDO_DELETE = "Successfully Added back last deleted task!";
	public static final String MESSAGE_SUCCESS_UNDO_ADD = "Successfully deleted last added task!";
	public static final String MESSAGE_SUCCESS_UNDO_UPDATE = "Successfully updated task!";
	public static final String MESSAGE_FAILURE_UNDO = "Nothing to Undo!";

	public UndoCommand() {
	}

	@Override
	public CommandResult execute() {
		assert model != null;
		try {
			Undo undo = Undo.getInstance();
			switch (undo.getCommand()) {
			case ADD:
				model.deleteTask(undo.getTask());
				undo.setCommand(Undo.UndoCommand.DEFAULT);
				return new CommandResult(MESSAGE_SUCCESS_UNDO_ADD);
			case DELETE:
				model.addTask(undo.getTaskIndex(), undo.getTask());
				undo.setCommand(Undo.UndoCommand.DEFAULT);
				return new CommandResult(MESSAGE_SUCCESS_UNDO_DELETE);
			case UPDATE:
				//LogsCenter.getLogger(ModelManager.class).info("Task : " + undo.getTask().toString());
				model.updateTask(model.getTaskByIndex(undo.getTaskIndex()), undo.getTask());
				undo.setCommand(Undo.UndoCommand.DEFAULT);
				return new CommandResult(MESSAGE_SUCCESS_UNDO_UPDATE);
			case DEFAULT:
				return new CommandResult(MESSAGE_FAILURE_UNDO);
			}
		} catch (UniqueTaskList.DateClashTaskException e) {
			return new CommandResult(e.getMessage());
		} catch (TaskNotFoundException e) {
			assert false : "The target task cannot be missing";
			LogsCenter.getLogger(ModelManager.class).throwing(UndoCommand.class.getName(), "execute", e);
		} catch (DuplicateTaskException e) {
			return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
		}
		return new CommandResult(MESSAGE_FAILURE_UNDO);

	}
}
```
###### /java/seedu/task/logic/commands/UpdateCommand.java
``` java

import seedu.task.commons.core.LogsCenter;
import seedu.task.commons.core.Messages;
import seedu.task.commons.core.UnmodifiableObservableList;
import seedu.task.commons.exceptions.IllegalValueException;
import seedu.task.logic.parser.TaskParser;
import seedu.task.logic.parser.UpdateTaskParser;
import seedu.task.model.ModelManager;
import seedu.task.model.Undo;
import seedu.task.model.tag.UniqueTagList;
import seedu.task.model.task.ReadOnlyTask;
import seedu.task.model.task.Task;
import seedu.task.model.task.UniqueTaskList;

public class UpdateCommand extends Command{
    public static final String COMMAND_WORD = "update";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Updates the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1 by Sunday";

    public static final String MESSAGE_SUCCESS = "Updated task %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the taskBook";

    private final int taskIndex;
    private final String updateArgs;

    
    /**
     * Parameter: Task Index, Arguments to be updated
     *
     * 
     */
    public UpdateCommand(int taskIndex, String updateArgs) {
    	this.taskIndex = taskIndex;
    	this.updateArgs = updateArgs;
    }

    @Override
    public CommandResult execute() {
    	LogsCenter.getLogger(ModelManager.class).info("Task Index: " + taskIndex + " Args: " + updateArgs);
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getSortedTaskList();

        if (lastShownList.size() < taskIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
    	
        assert model != null;
        try {
            Task toUpdate = ((Task)lastShownList.get(taskIndex - 1)).clone();
            TaskParser updateTaskParser = new UpdateTaskParser((Task)lastShownList.get(taskIndex - 1), updateArgs);
        	model.updateTask(model.getTaskByIndex(taskIndex - 1), updateTaskParser.parseInput());
        	Undo.getInstance().setUndo(taskIndex - 1, toUpdate, Undo.UndoCommand.UPDATE);
            LogsCenter.getLogger(ModelManager.class).info("toUpdate: " + Undo.getInstance().getTask().toString() + " UndoCommand: " + Undo.getInstance().getCommand());

        } catch (UniqueTaskList.DateClashTaskException e) {
            return new CommandResult(e.getMessage());
		} catch (IllegalValueException e) {
	        indicateAttemptToExecuteIncorrectCommand();
			return new CommandResult(e.getMessage());
		}

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskIndex));
    }
}
```
###### /java/seedu/task/logic/parser/Parser.java
``` java
    
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        TaskParser taskParser = new TaskParser(args);
        try {
            return new AddCommand(taskParser.parseInput());
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

    /**
     * 
     * Parses arguments in the context of the update task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        Pair<Optional<Integer>, Optional<String>> argsPair = parseIndexWithArgs(args);

        if (!argsPair.getLeft().isPresent() || !argsPair.getRight().isPresent())
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));

        return new UpdateCommand(argsPair.getLeft().get(), argsPair.getRight().get());
    }

    /**
     * 
     * Parses arguments in the context of the set task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSet(String args) {
        logger.info("args: " + args);
        Pair<Optional<Integer>, Optional<String>> argsPair = parseIndexWithArgs(args);
        logger.info("left: " + argsPair.getLeft() + " right: " + argsPair.getRight());

        if (!argsPair.getLeft().isPresent() || !argsPair.getRight().isPresent())
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SetCommand.MESSAGE_USAGE));

        return new SetCommand(argsPair.getLeft().get(), argsPair.getRight().get());
    }
    
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

    	Optional<int[]> indexes = parseIndexes(args);
    	if (!indexes.isPresent())
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
    	
    	return new DeleteCommand(indexes.get());
    }
    
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned
     * integer is given as the index. Returns an {@code Optional.empty()}
     * otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_FORMAT.matcher(command.trim());

        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
    
    /**
     * Returns all indexes in the {@code command} IF positive unsigned
     * integers is given as the indexes. Returns an {@code Optional.empty()}
     * otherwise.
     */
    private Optional<int[]> parseIndexes(String command) {
        final Matcher matcher = TASK_INDEXES_FORMAT.matcher(command.trim());

        if (!matcher.matches()) {
            return Optional.empty();
        }

        String[] match = matcher.group("targetIndexes").split(SPLIT_STRING_BY_WHITESPACE);
        int[] indexes = new int[match.length];
        
        for (int i = 0; i < indexes.length; i++) {
            if (!StringUtil.isUnsignedInteger(match[i]))
                return Optional.empty();
            else
            	indexes[i] = Integer.parseInt(match[i]);
        }
        logger.info("Delete Indexes: " + Arrays.toString(indexes));
        return Optional.of(indexes);

    }

    /**
     * Processes the command with an index followed by a series of arguments.
     * Returns the specified index in the {@code command} and the arguments IF a
     * positive unsigned integer is given as the index and if arguments are
     * present. Returns an {@code Optional.empty()} otherwise
     */
    private Pair<Optional<Integer>, Optional<String>> parseIndexWithArgs(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        // logger.info("left: " + argsPair.getLeft() + " right: " +
        // argsPair.getRight());

        if (!matcher.matches()) {
            return new ImmutablePair<Optional<Integer>, Optional<String>>(Optional.empty(), Optional.empty());
        }

        String index = matcher.group("targetIndex");
        String args = matcher.group("arguments");
        if (!StringUtil.isUnsignedInteger(index) || args.isEmpty()) {
            return new ImmutablePair<Optional<Integer>, Optional<String>>(Optional.empty(), Optional.empty());
        }
        return new ImmutablePair<Optional<Integer>, Optional<String>>(Optional.of(Integer.parseInt(index)),
                Optional.of(args));
    }
    
```
###### /java/seedu/task/logic/parser/TaskParser.java
``` java

public class TaskParser {

	public static final String SPLIT_STRING_BY_WHITESPACE = "\\s+";
	public static final String REGEX_CASE_INSENSITIVE = "(?i)";
	public static final String WHITE_SPACE = " ";
	public static final String PREFIX_HASHTAG = "#";
	public static final String PREFIX_AT = "@";
	public static final String AT = "at ";
	public static final String FROM = "from ";
	public static final String BY = "by ";
	public static final String NULL = "NULL";

	protected static final Logger logger = LogsCenter.getLogger(TaskParser.class);
	private Task task;
	private String input;

	public TaskParser(String input) {
		this(new Task(), input);
	};

	public TaskParser(Task task, String input) {
		this.task = task;
		this.input = input;
	};

	public Task parseInput() throws IllegalValueException {
		input = tagIdentification(input);
		input = dateIdentification(input, FROM, FROM.trim().length());
		input = dateIdentification(input, BY, BY.trim().length());
		validateStartDate();
		processTaskName(input);

		logger.info("parseInput: " + task.toString());

		return task;
	}

	protected String tagIdentification(String str) throws DuplicateTagException, IllegalValueException {
		String[] parts = str.split(SPLIT_STRING_BY_WHITESPACE);
		String strWithNoTags = "";
		for (String part : parts) {
			if (part.startsWith(PREFIX_HASHTAG))
				strWithNoTags = matchTag(strWithNoTags, part.substring(1).trim());
			else if (part.startsWith(PREFIX_AT)) {
				if (part.substring(1).trim().equalsIgnoreCase(NULL))
					task.setVenue(new Venue(""));
				else
					task.setVenue(new Venue(String.join(" ", task.getVenue().toString(), part.substring(1))));
			} else
				strWithNoTags = String.join(" ", strWithNoTags, part.trim());
		}
		return strWithNoTags;
	}

	protected String matchTag(String str, String tag) throws DuplicateTagException, IllegalValueException {	
		if (tag.equalsIgnoreCase(NULL))
			str = dateMatch(str);
		else if (EnumUtils.isValidEnum(TaskPriority.class, tag.toUpperCase()))
			task.setPriority(TaskPriority.valueOf(tag.toUpperCase()));
		else if (EnumUtils.isValidEnum(PinTask.class, tag.toUpperCase()))
			task.setPinTask(PinTask.valueOf(tag.toUpperCase()));
		else
			task.addTag(new Tag(tag));
		return str;
	}

	protected String dateIdentification(String str, String dateType, int strLength) throws IllegalValueException {
		String[] parts = str.split("(?=" + REGEX_CASE_INSENSITIVE + dateType + ")");
		logger.info("dateIdentification: " + Arrays.toString(parts));
		StringJoiner processedString = new StringJoiner(WHITE_SPACE);

		for (int i = 0; i < parts.length; i++) {
			if (startsWithIgnoreCase(parts[i], dateType)) {
				String result = processDateNLP(parts[i], dateType);
				if (!result.equals(parts[i]))
					parts[i] = result.substring(strLength);
			}

			processedString.add(parts[i].trim());
			logger.info("dateIdentification length: " + parts.length + " strWithNoDates:" + processedString.toString() + " part: " + parts[i]);
		}
		return processedString.toString();
	}

	protected String dateMatch(String str) throws IllegalValueException {
		logger.info("dateMatch Str:" + str);
		String lastWord = StringUtils.stripEnd(str, " ").substring(str.lastIndexOf(" ") + 1);

		if (StringUtils.containsIgnoreCase(lastWord, FROM.trim()))
			task.setStartDate(new DateTime(""));
		else if (StringUtils.containsIgnoreCase(lastWord, BY.trim()))
			task.setEndDate(new DateTime(""));
		else
			throw new IllegalValueException(Tag.MESSAGE_HASHTAG_NULL_CONSTRAINTS);
		logger.info("dateMatch Str1:" + str);
		return replaceLast(str, lastWord, "");
	}

	protected String processDateNLP(String str, String dateType) throws IllegalValueException {
		Parser parser = new Parser();
		List<DateGroup> groups = parser.parse(str);
		List<Date> dates = new ArrayList<>();

		if (!groups.isEmpty()) {
			dates.addAll(groups.get(0).getDates());
			Collections.sort(dates);
			String matchingValue = groups.get(0).getText();
			str = str.replace(matchingValue, WHITE_SPACE);
			logger.info("groups size:  " + groups.size() + " Str: " + str + " dates " + Arrays.toString(dates.toArray())
			        + " matchingValue: " + matchingValue);
		}

		if (!dates.isEmpty()) {
			if (dateType.equalsIgnoreCase(FROM))
				setStartDate(dates);
			else if (dateType.equalsIgnoreCase(BY))
				setEndDate(dates);
		}

		return str;
	}

	protected void setStartDate(List<Date> dates) throws IllegalValueException {
		if (!task.getStartDate().value.isEmpty())
			throw new IllegalValueException(DateTime.MESSAGE_MULTIPLE_START_DATE);

		if (dates.size() == 1) {
			task.setStartDate(new DateTime(dates.get(0)));
		} else if (dates.size() >= 2) {
			if (dates.get(0).compareTo(dates.get(1)) == 0)
				throw new IllegalValueException(DateTime.MESSAGE_DATE_SAME);
			task.setStartDate(new DateTime(dates.get(0)));
			task.setEndDate(new DateTime(dates.get(1)));
		}
	}
	
	protected void setEndDate(List<Date> dates) throws IllegalValueException {
		if (!task.getEndDate().value.isEmpty())
			throw new IllegalValueException(DateTime.MESSAGE_MULTIPLE_END_DATE);
		task.setEndDate(new DateTime(dates.get(dates.size()-1)));
	}
	
	protected void validateStartDate() throws IllegalValueException {
		if (!task.getStartDate().value.isEmpty() && !task.getEndDate().value.isEmpty()) {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("E MMM d HH:mm:ss zzz yyyy");

			LocalDateTime startDate = LocalDateTime.parse(task.getStartDate().value, formatter);
			LocalDateTime endDate = LocalDateTime.parse(task.getEndDate().value, formatter);
			if (!startDate.isBefore(endDate))
				throw new IllegalValueException(DateTime.MESSAGE_INVALID_START_DATE);
		}
	}

	protected void processTaskName(String str) throws IllegalValueException {
		task.setName(new Name(str));
	}

	protected boolean startsWithIgnoreCase(String str, String prefix) {
		return startsWith(str, prefix, true);
	}

	protected boolean startsWith(String str, String prefix, boolean ignoreCase) {
		if (str == null || prefix == null) {
			return (str == null && prefix == null);
		}
		if (prefix.length() > str.length()) {
			return false;
		}
		return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());
	}
	
	protected String replaceLast(String string, String toReplace, String replacement) {
	    int pos = string.lastIndexOf(toReplace);
	    if (pos > -1) {
	        return string.substring(0, pos)
	             + replacement
	             + string.substring(pos + toReplace.length(), string.length());
	    } else {
	        return string;
	    }
	}
}
```
###### /java/seedu/task/logic/parser/UpdateTaskParser.java
``` java

public class UpdateTaskParser extends TaskParser{

	private Task task;
	private String input;
	private boolean isVenueUpdated;
	private boolean isStartDateUpdated;
	private boolean isEndDateUpdated;


	public UpdateTaskParser(String input) {
		this(new Task(), input);
	};
	
	public UpdateTaskParser(Task task, String input) {
		super(task, input);
		this.task = task;
		this.input = input;
		isVenueUpdated = false;
		isStartDateUpdated = false;
		isEndDateUpdated = false;
	};

	@Override
	protected String tagIdentification(String str) throws DuplicateTagException, IllegalValueException {
		String[] parts = str.split(SPLIT_STRING_BY_WHITESPACE);
		String strWithNoTags = "";
		for (String part : parts) {
			if (part.startsWith(PREFIX_HASHTAG))
				strWithNoTags = matchTag(strWithNoTags, part.substring(1).trim());
			else if (part.startsWith(PREFIX_AT)) {
				if (!isVenueUpdated) {
					isVenueUpdated = true;
					task.setVenue(new Venue(""));
				}
				if (part.substring(1).trim().equalsIgnoreCase(NULL))
					task.setVenue(new Venue(""));
				else
					task.setVenue(new Venue(String.join(" ", task.getVenue().toString(), part.substring(1))));
			} else
				strWithNoTags = String.join(" ", strWithNoTags, part.trim());
		}
		return strWithNoTags;	
	}
	
	protected String matchTag(String str, String tag) throws DuplicateTagException, IllegalValueException {
		if (tag.equalsIgnoreCase(NULL))
			str = dateMatch(str);
		else if (EnumUtils.isValidEnum(TaskPriority.class, tag.toUpperCase()))
			task.setPriority(TaskPriority.valueOf(tag.toUpperCase()));
		else if (EnumUtils.isValidEnum(PinTask.class, tag.toUpperCase()))
			task.setPinTask(PinTask.valueOf(tag.toUpperCase()));
		else
			task.updateTag(new Tag(tag));
		return str;
	}
	
	
	protected void setStartDate(List<Date> dates) throws IllegalValueException {
		if (!task.getStartDate().value.isEmpty() && isStartDateUpdated)
			throw new IllegalValueException(DateTime.MESSAGE_MULTIPLE_START_DATE);
		
		isStartDateUpdated = true;
		if (dates.size() == 1) {
			task.setStartDate(new DateTime(dates.get(0)));
		} else if (dates.size() >= 2) {
			if (dates.get(0).compareTo(dates.get(1)) == 0)
				throw new IllegalValueException(DateTime.MESSAGE_DATE_SAME);
			task.setStartDate(new DateTime(dates.get(0)));
			task.setEndDate(new DateTime(dates.get(1)));
		}
	}
	
	protected void setEndDate(List<Date> dates) throws IllegalValueException {
		if (!task.getEndDate().value.isEmpty() && isEndDateUpdated)
			throw new IllegalValueException(DateTime.MESSAGE_MULTIPLE_END_DATE);
		
		isEndDateUpdated = true;
		task.setEndDate(new DateTime(dates.get(dates.size()-1)));
	}
	
	@Override
	protected void processTaskName(String str) throws IllegalValueException {
		if (!str.trim().isEmpty())
			task.setName(new Name(str));
	}
	
	public Task setTaskStatus() throws IllegalValueException {
		
		LogsCenter.getLogger(Task.class).info("input : " + input.trim().toUpperCase() + " Status: " + Status.DONE);

		if (!task.getStatus().equals(Status.DONE)) {
			if (input.trim().toUpperCase().equals(Status.DONE.toString()) || input.trim().toUpperCase().equals(Status.IGNORE.toString()))
				task.setStatus(Status.valueOf(input.trim().toUpperCase()));
			else
				throw new IllegalValueException(SetCommand.MESSAGE_STATUS_CONSTRAINT);
		} else if (task.getStatus().equals(Status.DONE))
			throw new IllegalValueException(SetCommand.MESSAGE_STATUS_DONE);
		else
			throw new IllegalValueException(Messages.MESSAGE_FAILURE_SET_COMMAND);
		return task;
	}
}
```
###### /java/seedu/task/model/ModelManager.java
``` java
    
    @Override
    public synchronized int addTask(Task task) throws UniqueTaskList.DuplicateTaskException, DateClashTaskException {
        int position = taskBook.addTask(task);
        updateFilteredListToShowAll();
        sortedTasks = new SortedList<>(filteredTasks, new TaskComparator());
        indicateTaskBookChanged();
        return position;
    }
    
    @Override
    public synchronized int addTask(int index, Task task) throws UniqueTaskList.DuplicateTaskException, DateClashTaskException {
        int position = taskBook.addTask(index, task);
        updateFilteredListToShowAll();
        sortedTasks = new SortedList<>(filteredTasks, new TaskComparator());
        indicateTaskBookChanged();
        return position;
    }
    
	@Override
	public synchronized void updateTask(Task toReplace, Task toUpdate) throws DateClashTaskException {
        taskBook.updateTask(toReplace, toUpdate);
        updateFilteredListToShowAll();
        sortedTasks = new SortedList<>(filteredTasks, new TaskComparator());
        indicateTaskBookChanged();		
	}
	
	public synchronized void updateTaskStatus() {
		taskBook.updateTaskStatus();
        updateFilteredListToShowAll();
        sortedTasks = new SortedList<>(filteredTasks, new TaskComparator());
        indicateTaskBookChanged();	
	}	
	
```
###### /java/seedu/task/model/task/DateTime.java
``` java

/**
 * Represents a Task's start date/end date in the task book.
 * Guarantees: immutable; is valid as declared in {@link #isValidDate(String)}
 */
public class DateTime {

    public static final String MESSAGE_DATE_CONSTRAINTS = "Date should be an upcoming date";
    public static final String MESSAGE_DATE_SAME = "Start date and End date should not be same";
    public static final String MESSAGE_MULTIPLE_START_DATE = "There are multiple start dates in your input. Please enter a valid task!";
    public static final String MESSAGE_MULTIPLE_END_DATE = "There are multiple end dates in your input. Please enter a valid task!";
    public static final String MESSAGE_INVALID_START_DATE = "Start Date should be before End Date!";

    
    public final String value;
    

    /**
     * Validates given Date.
     *
     * @throws IllegalValueException if given phone string is invalid.
     */
    public DateTime(Date date) throws IllegalValueException {
        if (!isValidDate(date)) {
            throw new IllegalValueException(MESSAGE_DATE_CONSTRAINTS);
        }
        this.value = date.toString();
    }

    public DateTime (String date){
        this.value = date;
    }
    
    
    /**
     * Returns true if a given Date is valid and in future
     */
    public static boolean isValidDate(Date date) {
        return date.after(new Date());
    }

    @Override
    public String toString() {
        return value.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DateTime // instanceof handles nulls
                && this.value.equals(((DateTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/task/model/task/Name.java
``` java

/**
 * Represents a Task's name in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Task names should be spaces or alphanumeric characters";
    public static final String NAME_VALIDATION_REGEX = "[\\p{Alnum} ]+";

    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        name = name.trim();
        if (!isValidName(name)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = name;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX);
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
```
###### /java/seedu/task/model/task/PinTask.java
``` java

public enum PinTask {
	PIN("PIN"), UNPIN("UNPIN");

	private final String text;

	private PinTask(final String text) {
		this.text = text;
	}

	@Override
	public String toString() {
		return text;
	}
	
	public boolean isPinned() {
	    if(text.equals("PIN")) {
	        return true;
	    }
	    return false;
	}
}
```
###### /java/seedu/task/model/task/ReadOnlyTask.java
``` java

/**
 * A read-only immutable interface for a Task in the taskBook.
 * Implementations should guarantee: details are present and not null, field values are validated.
 */
public interface ReadOnlyTask {

    Name getName();
    DateTime getStartDate();
    DateTime getEndDate();
    Venue getVenue();
    TaskPriority getPriority();
    Status getStatus();
    PinTask getPinTask();

    /**
     * The returned TagList is a deep copy of the internal TagList,
     * changes on the returned list will not affect the task's internal tags.
     */
    UniqueTagList getTags();

    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this; 
    }
    
```
###### /java/seedu/task/model/task/ReadOnlyTask.java
``` java

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }

}
```
###### /java/seedu/task/model/task/Status.java
``` java

public enum Status {
	ACTIVE("ACTIVE"), EXPIRED("EXPIRED"), DONE("DONE"), IGNORE("IGNORE");

	private final String text;

	private Status(final String text) {
		this.text = text;
	}

	@Override
	public String toString() {
		return text;
	}
}
```
###### /java/seedu/task/model/task/Task.java
``` java

/**
 * Represents a Task in the taskBook. Guarantees: details are present and not
 * null, field values are validated.
 */
public class Task implements ReadOnlyTask, Cloneable {

	private Name name;
	private DateTime startDate;
	private DateTime endDate;
	private Venue venue;
	private Status status = Status.ACTIVE;
	private TaskPriority priority = TaskPriority.MEDIUM; // Default priority is medium
	private PinTask pinTask = PinTask.UNPIN; // Default is unpin
	private UniqueTagList tags;

	/**
	 * Only Name, Priority and Status Should not be null
	 */
	public Task(Name name, DateTime startDate, DateTime endDate, Venue venue, TaskPriority priority, Status status,
	        PinTask pinTask, UniqueTagList tags) {
		assert !CollectionUtil.isAnyNull(name, priority, status);
		this.name = name;
		this.startDate = startDate;
		this.endDate = endDate;
		this.setVenue(venue);
		this.priority = priority;
		this.status = status;
		this.pinTask = pinTask;
		this.tags = new UniqueTagList(tags);
	}

	/**
	 * Copy constructor.
	 */
	public Task(ReadOnlyTask source) {
		this(source.getName(), source.getStartDate(), source.getEndDate(), source.getVenue(), source.getPriority(),
		        source.getStatus(), source.getPinTask(), source.getTags());
	}

	/**
	 * Empty Task Constructor.
	 */
	public Task() {
		this.startDate = new DateTime("");
		this.endDate = new DateTime("");
		this.venue = new Venue("");
		this.tags = new UniqueTagList();
	}

	public boolean checkDateClash(Task task) {
		if (!task.getStartDate().value.isEmpty() && !task.getEndDate().value.isEmpty()) {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("E MMM d HH:mm:ss zzz yyyy");

			LocalDateTime startDate = LocalDateTime.parse(this.startDate.value, formatter);
			LocalDateTime endDate = LocalDateTime.parse(this.endDate.value, formatter);
			LocalDateTime taskStartDate = LocalDateTime.parse(task.startDate.value, formatter);
			LocalDateTime taskEndDate = LocalDateTime.parse(task.endDate.value, formatter);

			LogsCenter.getLogger(ModelManager.class).info("startDate: " + startDate + ", endDate: " + endDate
			        + ", taskStartDate: " + taskStartDate + ", taskEndDate: " + taskEndDate);

			if (startDate.compareTo(taskStartDate) >= 0 && endDate.compareTo(taskEndDate) <= 0)
				return true;
		}

		return false;
	}

	public void updateTaskStatus() {
		if (!this.getEndDate().value.isEmpty()) {
			DateTimeFormatter formatter = DateTimeFormatter.ofPattern("E MMM d HH:mm:ss zzz yyyy");
			LocalDateTime endDate = LocalDateTime.parse(this.getEndDate().value, formatter);
			if (endDate.isBefore(LocalDateTime.now()))
				this.setStatus(Status.EXPIRED);
		}
	}

	@Override
	public Name getName() {
		return name;
	}

	public void setName(Name name) {
		this.name = name;
	}

	@Override
	public Venue getVenue() {
		return venue;
	}

	public void setVenue(Venue venue) {
		this.venue = venue;
	}

	@Override
	public UniqueTagList getTags() {
		return new UniqueTagList(tags);
	}

	/**
	 * Replaces this task's tags with the tags in the argument tag list.
	 */
	public void setTags(UniqueTagList replacement) {
		tags.setTags(replacement);
	}

	@Override
	public boolean equals(Object other) {
		return other == this // short circuit if same object
		        || (other instanceof ReadOnlyTask // instanceof handles nulls
		                && this.isSameStateAs((ReadOnlyTask) other));
	}

	@Override
	public int hashCode() {
		// use this method for custom fields hashing instead of implementing
		// your own
		return Objects.hash(getName(), getStartDate(), getEndDate(), getVenue(), getPriority(), getStatus(), getTags());
	}

	@Override
	public String toString() {
		return getAsText();
	}

	@Override
	public DateTime getStartDate() {
		return startDate;
	}

	public void setStartDate(DateTime startDate) {
		this.startDate = startDate;
	}

	@Override
	public DateTime getEndDate() {
		return endDate;
	}

	public void setEndDate(DateTime endDate) {
		this.endDate = endDate;
	}

	@Override
	public Status getStatus() {
		return status;
	}

	public void setStatus(Status status) {
		this.status = status;
	}

	@Override
	public TaskPriority getPriority() {
		return priority;
	}

	public void setPriority(TaskPriority priority) {
		this.priority = priority;
	}

	@Override
	public PinTask getPinTask() {
		return pinTask;
	}

	public void setPinTask(PinTask pinTask) {
		this.pinTask = pinTask;
	}

	public void addTag(Tag tag) throws DuplicateTagException {
		this.tags.add(tag);
	}

	public void updateTag(Tag tag) {
		try {
			this.tags.add(tag);
		} catch (DuplicateTagException e) {
			this.tags.remove(tag);
		}
	}

	public Task clone() {
		try {
			this.setTags(getTags().clone());
			return (Task) super.clone();
		} catch (CloneNotSupportedException e) {
			e.printStackTrace();
			throw new RuntimeException();
		}
	}
}
```
###### /java/seedu/task/model/task/TaskPriority.java
``` java

public enum TaskPriority {
	HIGH("HIGH"), MEDIUM("MEDIUM"), LOW("LOW");

	private final String text;

	private TaskPriority(final String text) {
		this.text = text;
	}

	@Override
	public String toString() {
		return text;
	}
}
```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
	
	/**
	 * Signals that the task would clash with another task.
	 */
	public static class DateClashTaskException extends DuplicateDataException {
		protected DateClashTaskException(String taskName) {
			super("The Start Date and End date clashes with another task '" + taskName + "'");
		}
	}

```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
	
	/**
	 * Returns the task if a clash in dates have been found
	 */
	public Task isDateClash(Task task) {
		if (!task.getStartDate().value.isEmpty() && !task.getEndDate().value.isEmpty()) {
			for (Task t : internalList) {
				if ((t != task) && task.checkDateClash(t))
					return t;
			}
		}
		return null;
	}

	/**
	 * Returns the task if a clash in dates have been found. It doesn't check
	 * with the task in the specified index
	 */
	public Task isDateClash(int index, Task task) {
		if (!task.getStartDate().value.isEmpty() && !task.getEndDate().value.isEmpty()) {
			for (int i = 0; i < internalList.size(); i++) {
				if ((i != index) && task.checkDateClash(internalList.get(i)))
					return internalList.get(i);
			}
		}
		return null;
	}

	/**
	 * Adds a task to the list.
	 *
	 * @throws DuplicateTaskException
	 *             if the task to add is a duplicate of an existing task in the
	 *             list.
	 * @throws DateClashTaskException
	 *             if the task dates clashes with another existing task in the
	 *             list
	 */
	public int add(Task toAdd) throws DuplicateTaskException, DateClashTaskException {
		assert toAdd != null;
		if (contains(toAdd)) {
			throw new DuplicateTaskException();
		}
		Task dateClash = isDateClash(toAdd);
		if (dateClash != null)
			throw new DateClashTaskException(dateClash.getName().toString());

		internalList.add(toAdd);
		return internalList.size() - 1;
	}

	/**
	 * Adds a task to the list in the specified index.
	 *
	 * @throws DuplicateTaskException
	 *             if the task to add is a duplicate of an existing task in the
	 *             list.
	 * @throws DateClashTaskException
	 *             if the task dates clashes with another existing task in the
	 *             list
	 */
	public int add(int index, Task toAdd) throws DuplicateTaskException, DateClashTaskException {
		assert toAdd != null;
		if (contains(toAdd)) {
			throw new DuplicateTaskException();
		}
		Task dateClash = isDateClash(toAdd);
		if (dateClash != null)
			throw new DateClashTaskException(dateClash.getName().toString());

		internalList.add(index, toAdd);
		return internalList.size() - 1;
	}

	/**
	 * Updates a task in the list.
	 *
	 * @throws DateClashTaskException
	 *             if the task dates clashes with another existing task in the
	 *             list
	 */
```
###### /java/seedu/task/model/task/UniqueTaskList.java
``` java
		LogsCenter.getLogger(ModelManager.class).info("Update index: " + index + " toUpdate: " + toUpdate.toString());
		Task dateClash = isDateClash(index, toUpdate);
		if (dateClash != null)
			throw new DateClashTaskException(dateClash.getName().toString());
		internalList.set(index, toUpdate);
		LogsCenter.getLogger(ModelManager.class).info("Update internalList: " + Arrays.toString(internalList.toArray()));
	}
	
	public void updateTaskStatus() {
		for (Task task : internalList) {
			task.updateTaskStatus();
		}
	}
	
```
###### /java/seedu/task/model/task/Venue.java
``` java

/**
 * Represents a Task's address in the address book.
 * Guarantees: immutable; is valid as declared in {@link #isValidVenue(String)}
 */
public class Venue {
    
    public static final String MESSAGE_VENUE_CONSTRAINTS = "Task venue can be in any format";
    public static final String VENUE_VALIDATION_REGEX = "";

    public final String value;

    /**
     * Validates given venue.
     *
     * Venue can be null
     */
    public Venue(String venue) {
        this.value = venue;
    }

    /**
     * Returns true if a given string is a valid person email.
     */
    public static boolean isValidVenue(String test) {
        return test.matches(VENUE_VALIDATION_REGEX);
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Venue // instanceof handles nulls
                && this.value.equals(((Venue) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/task/model/TaskBook.java
``` java
    
    /**
     * Adds a task to the task book at the specified index.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     * @throws DateClashTaskException 
     */
    public int addTask(int index, Task p) throws UniqueTaskList.DuplicateTaskException, DateClashTaskException {
        syncTagsWithMasterList(p);
        return tasks.add(index, p);
    }

    /**
     * Updates a task at the specified index to the task book.
     * Also checks the updates task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws DateClashTaskException 
     */
    public void updateTask(Task toReplace, Task toUpdate) throws DateClashTaskException {
        syncTagsWithMasterList(toUpdate);
        tasks.update(toReplace, toUpdate);
    }

    public void updateTaskStatus() {
    	tasks.updateTaskStatus();
    }
    
```
###### /java/seedu/task/model/Undo.java
``` java

public class Undo {
	public enum UndoCommand { ADD, UPDATE, DELETE, DEFAULT };
	
	private static Undo instance;
	private int taskIndex;
	private Task task;
	private UndoCommand command;
	
	private Undo() {
		this.command = UndoCommand.DEFAULT;
	};
	
	public static Undo getInstance() {
		if (instance == null)
			instance = new Undo();
		return instance;
	}
	
	public void setUndo(int taskIndex, Task undoTask, UndoCommand undoCommand) {
		setTaskIndex(taskIndex);
		setTask(undoTask);
		setCommand(undoCommand);
	}

	public int getTaskIndex() {
		return taskIndex;
	}

	public void setTaskIndex(int taskIndex) {
		this.taskIndex = taskIndex;
	}

	public Task getTask() {
		return task;
	}

	public void setTask(Task undoTask) {
		this.task = undoTask;
	}

	public UndoCommand getCommand() {
		return command;
	}

	public void setCommand(UndoCommand undoCommand) {
		this.command = undoCommand;
	}
	
}
```
###### /java/seedu/task/storage/XmlAdaptedTask.java
``` java

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;
    @XmlElement(required = true)
    private String startDate;
    @XmlElement(required = true)
    private String endDate;
    @XmlElement(required = true)
    private String venue;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    private String status;
    @XmlElement(required = true)
    private String pinTask;
    
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        startDate = source.getStartDate().value;
        endDate = source.getEndDate().value;
        venue = source.getVenue().value;
        priority = source.getPriority().toString();
        status = source.getStatus().toString();
        pinTask = source.getPinTask().toString();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Name name = new Name(this.name);
        final DateTime startDate = new DateTime(this.startDate);
        final DateTime endDate = new DateTime(this.endDate);
        final Venue venue = new Venue(this.venue);
        final TaskPriority priority = TaskPriority.valueOf(this.priority.toUpperCase());
        final Status status = Status.valueOf(this.status.toUpperCase());
        final PinTask pinTask = PinTask.valueOf(this.pinTask.toUpperCase());
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(name, startDate, endDate, venue, priority, status, pinTask, tags);
    }
}
```
